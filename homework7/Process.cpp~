#include "Process.h"

Process::Process(const std::vector<std::string> &args)
{
	//Checks the number of arguments
	if(args.size() == 0){
		perror("Not Enough Arguments");
		throw "Not Enough Arguments";
	}
	//Checks if the parent pipe write end is ok
	if(pipe(writepipe) == -1){
		perror("Pipe write issue");
		throw "Pipe write issue";
	}
	//Checks if the parent pipe read end is ok
	if(pipe(readpipe) == -1){
		perror("Pipe read issue");
		throw "Pipe read issue";	
	}

	//Forks a Child Process
	m_pid = fork();

	if(m_pid < 0){
		perror("Process fork issue");
		throw "Process Fork Issue";
	}
	else if(m_pid == 0){
	//if child Process
		close(writepipe[0]);
		close(readpipe[0]);
		dup2(writepipe[1],1);
		close(writepipe[1]);
		dup2(readpipe[1],0); 
		close(readpipe[0]);
		std::vector<const char*> cargs;
		std::transform(args.begin(),args.end(), std::back_inserter(cargs), 
		[](std::string s) {
				return s.c_str();
			} );
		cargs.push_back( NULL );
		int erroCheck = execv(cargs[0], const_cast<char**>(&cargs[0]));
       		//int erroCheck = execv(args[0].c_str(), NULL);
    		if(erroCheck < 0){
     			perror("Error: Running Generator");
      			exit(1);
		}
	}
	else{
	//if parent Process
		std::cerr << "Process[" << pid()-1 <<"] Process constructor " << std::endl;
		close(writepipe[0]); // Parent pipe write is closed
		close(writepipe[1]); //Childe pipe write is closed
		close(readpipe[1]); // Child pipe read is closed
		m_pread = fdopen(readpipe[0], "r");

	}
}

Process::~Process()
{
	int status;
	pid_t pid = waitpid(m_pid, &status, 0);
	if(pid < 0){
        	perror("Error: ~Process waitpid");
        	throw "Error: ~Process waitpid";
    	}

	close(readpipe[0]);
	close(writepipe[0]);

	// Kill the child process
	kill(m_pid, SIGTERM);	
}

void Process::write(const std::string& str)
{
	::write(writepipe[1], str.c_str(), str.length());
}

std::string Process::readline()
{
	std::string readLine;
	char* buffer = NULL;
	size_t buffer_size;

	getline(&buffer, &buffer_size, m_pread);
	readLine = buffer;
	return readLine;
}
